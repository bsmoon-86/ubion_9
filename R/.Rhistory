'pass',
ifelse(
df$mean == 65,
'hold',
'fail'
)
)
# 평균 점수가 65점 초과이면 'pass' 65점 미만이면 'fail' 65점이면 'hold'
ifelse(
df$mean > 65,
'pass',
ifelse(
df$mean == 65,
'hold',
'fail'
)
) -> df$result
df
# 외부의 패키지 파일을 설치
install.packages('dplyr')
# 패키지를 로드
library(dplyr)
install.packages("ggplot2")
library(ggplot2)
df <- read.csv('csv/csv_exam.csv')
head(df)
# filter(조건식) : 인덱스의 조건
df %>% filter(class == 1)
# Base
# 조건식 생성
df$class == 1
df[df$class == 1, ]
# select(조건식) : 컬럼의 조건
df %>% select('class')
# select(조건식) : 컬럼의 조건
df %>% select('class', 'math')
#Base
df[c('class', 'math')]
# 특정 컬럼을 제외하고 출력
df %>% select(-id)
# 인덱스의 조건과 컬럼의 조건을 모두 사용
df %>% filter(class == 1) %>% select(math, english)
# Base
df[ df$class == 1 , c['math', 'english'] ]
# Base
df[ df$class == 1 , c('math', 'english') ]
# 정렬을 변경(오름차순, 내림차순)
df %>% arrange(math)
df %>% arrange(desc(math))
df %>% arrange(-math)
# Base
order(df$math)
# Base
df[order(df$math),]
df[order(df$math, decreasing = TRUE), ]
df[order(-df$math), ]
# 정렬의 기준이 2개인 경우
df  %>%  arrange(desc(class), math)
order(c(-df$class, df$math))
df[order(c(-df$class, df$math)), ]
df[order(c(df$class, df$math)), ]
# 그룹화 연산
df %>% group_by(class) %>%
summarise(mean_math = mean(math),
mean_english= mean(english),
mean_science = mean(science))
library(dplyr)
# 단순한 행 결합 -> 유니언 결합
df_1 <- data.frame(
id = 1:5,
score = c(70, 80, 90, 60, 100)
)
df_2 <- data.frame(
id = 4:8,
weight = c(80, 70, 60, 75, 55)
)
rbind(df_1, df_2)
df_3 <- data.frame(
id = 11:13,
score = c(100, 80, 70)
)
rbind(df_1, df_3)
bind_rows(df_1, df_2)
bind_rows(df_1, df_3)
bind_cols(df_1, df_3)
bind_cols(df_1, df_2)
df_4 <- data.frame(
id = c('test', 'test2', 'test3', 'test4'),
company = c('A', 'A', 'B', 'D')
)
# 소속의 정보를 나타내는 데이터프레임
df_5 <- data.frame(
company = c('A', 'B', 'C'),
loc = c('seoul', 'busan', 'ulsan')
)
# 교집합
# inner_join(데이터프레임명1, 데이터프레임명2, by='조건')
inner_join(df_4, df_5, by='company')
#왼쪽 데이터프레임을 기준으로 조인 결합
# left_join()
left_join(df_4, df_5, by='company')
# 오른쪽 데이터프레임을 기준으로 조인 결합
# right_join()
right_join(df_4, df_5, by='company')
# 합집합
# full_join()
full_join(df_4, df_5, by='company')
bind_rows(df_1, df_2, df_3)
df_6 <- data.frame(
id = c('test', 'test2', 'test3', 'test4'),
pass = c('1234', '1111', '2222', '3333')
)
# 3개의 데이터프레임을 조인 결합
# df_4, df_6를 조인 결합
inner_join(df_4, df_6, by='id')
# 3개의 데이터프레임을 조인 결합
# df_4, df_6를 조인 결합
total_df <- inner_join(df_4, df_6, by='id')
# df_5 조인 결합
left_join(total_df, df_5, by='company')
library(ggplot2)
midwest <- ggplot2::midwest
View(midwest)
# 컬럼의 이름을 변경
# rename(기준의 데이터프레임, 새로운 컬럼의 이름 = 기준이 되는 컬럼의 이름)
# midwest에서 popasian컬럼의 이름을 asian 변경
# poptotal컬럼의 이름을 total 변경
rename(midwest, asian = popasian)
# 컬럼의 이름을 변경
# rename(기준의 데이터프레임, 새로운 컬럼의 이름 = 기준이 되는 컬럼의 이름)
# midwest에서 popasian컬럼의 이름을 asian 변경
# poptotal컬럼의 이름을 total 변경
rename(midwest, asian = popasian) -> midwest
View(midwest)
rename(midwest, total = poptoal)
rename(midwest, total = poptotal)
rename(midwest, total = poptotal) -> midwest
View(midwest)
View(midwest)
# 특정 컬럼들만 선택
midwest %>% select(country, total, asian)
# 특정 컬럼들만 선택
midwest %>% select(county, total, asian)
midwest[c('county', 'total', 'asian')]
midwest[c('county', 'total', 'asian')] -> df
# 전체 인구수 대비 아시안 인구 비율
# ratio컬럼을 생성하여 아시안 인구 비율
# (아시아인 인구수 / 전체 인구수) * 100
df$asian
df$total
# 전체 인구수 대비 아시안 인구 비율
# ratio컬럼을 생성하여 아시안 인구 비율
# (아시아인 인구수 / 전체 인구수) * 100
df$asian / df$total
# 전체 인구수 대비 아시안 인구 비율
# ratio컬럼을 생성하여 아시안 인구 비율
# (아시아인 인구수 / 전체 인구수) * 100
(df$asian / df$total) * 100
# 전체 인구수 대비 아시안 인구 비율
# ratio컬럼을 생성하여 아시안 인구 비율
# (아시아인 인구수 / 전체 인구수) * 100
(df$asian / df$total) * 100 -> ratio
cbind(df, ratio)
df$ratio <- ratio
df
df %>% mutate(ratio = (asian / total)*100)
midwest[c('county', 'total', 'asian')] -> df
df
df %>% mutate(ratio = (asian / total)*100)
midwest %>%
select(county, total, asian) %>%
mutate(ratio = (asian / total)*100)
# 히스토그램 출력
hist(df$ratio)
df
df %>% mutate(ratio = (asian / total)*100) -> df
# 히스토그램 출력
hist(df$ratio)
# ratio 전체 평균 값 출력
# 백터 데이터의 평균
mean(df$ratio)
# ratio 전체 평균 값 출력
# 백터 데이터의 평균
mean(df$ratio) -> mean_ratio
# ratio 평균 값보다 해당하는 지역의 ratio 값이 높으면 large
# 이하면 small이라는 데이터를 group 컬럼에 데이터를 대입
df$ratio
# ratio 평균 값보다 해당하는 지역의 ratio 값이 높으면 large
# 이하면 small이라는 데이터를 group 컬럼에 데이터를 대입
df$ratio > mean_ratio
a <- c()
a[1] = 5
a[2] = 1
dim(df)
dim(df$ratio)
ifelse(df$ratio > mean_ratio, 'large', 'small')
# 벡터데이터에 데이터를 추가
a <- c()
a[1] <- 3
a
a[2] <- 5
a
# ifelse() 함수와 같은 행동을 하는 함수 생성
iftest <- function(flag, t, f){
# 벡터 데이터를 하나 생성(원소의 개수가 0)
result <- c()
# flag는 데이터의 타입 : 벡터
# flag의 길이만큼 반복 실행하는 반복문을 생성
# 초기값 지정
i <- 1
# flag 벡터데이터의 길이만큼 반복
while i <= length(flag){
# flag에 있는 i번째 데이터가 TRUE인 경우
if(flag[i]){
# 비어있는 벡터데이터의 i번째 항목에 t 변수의 데이터를 대입
result[i] = t
# flag에 있는 i번째 데이터가 FALSE인 경우
}else{
# 비어있는 벡터데이터의 i번째 항목에 f 변수의 데이터를 대입
result[i] = f
}
# i 값을 1씩 증가
i = i + 1
}
return (result)
}
iftest <- function(flag, t, f){
# 벡터 데이터를 하나 생성(원소의 개수가 0)
result <- c()
# flag는 데이터의 타입 : 벡터
# flag의 길이만큼 반복 실행하는 반복문을 생성
# 초기값 지정
i <- 1
# flag 벡터데이터의 길이만큼 반복
while i <= length(flag){
# flag에 있는 i번째 데이터가 TRUE인 경우
if(flag[i]){
# 비어있는 벡터데이터의 i번째 항목에 t 변수의 데이터를 대입
result[i] = t
# flag에 있는 i번째 데이터가 FALSE인 경우
}else{
# 비어있는 벡터데이터의 i번째 항목에 f 변수의 데이터를 대입
result[i] = f
}
# i 값을 1씩 증가
i = i + 1
}
return (result)
}
# ifelse() 함수와 같은 행동을 하는 함수 생성
iftest <- function(flag, t, f){
# 벡터 데이터를 하나 생성(원소의 개수가 0)
result <- c()
# flag는 데이터의 타입 : 벡터
# flag의 길이만큼 반복 실행하는 반복문을 생성
# 초기값 지정
i <- 1
# flag 벡터데이터의 길이만큼 반복
while (i <= length(flag)){
# flag에 있는 i번째 데이터가 TRUE인 경우
if(flag[i]){
# 비어있는 벡터데이터의 i번째 항목에 t 변수의 데이터를 대입
result[i] = t
# flag에 있는 i번째 데이터가 FALSE인 경우
}else{
# 비어있는 벡터데이터의 i번째 항목에 f 변수의 데이터를 대입
result[i] = f
}
# i 값을 1씩 증가
i = i + 1
}
return (result)
}
iftest(df$ratio > mean_ratio, 'large', 'small')
df$group <- iftest(df$ratio > mean_ratio, 'large', 'small')
df
# group 컬럼의 데이터들의 데이터 개수를 체크
table(df$group)
qplot(df%group)
qplot(df$group)
## midwest 데이터 정제
## popadult 컬럼 : 해당 지역의 성인 인구수
## poptotal 컬럼 : 해당 지역의 전체 인구수
##
midwest <- ggplot2::midwest
midwest2 <- midwest
rename(midwest, adult = popadults)
rename(midwest, adult = popadults) -> midwest
midwest <- rename(midwest, total=poptotal)
midwest2 <- midwest
## base
midwest[c('county', 'adult', 'total')]
## base
midwest[c('county', 'adult', 'total')] -> midwest
midwest$total - midwest$adult
midwest$total - midwest$adult -> midwest$child
(midwest$child / midwest$total) * 100
(midwest$child / midwest$total) * 100 -> midwest$child_ratio
# child_ratio를 기준으로 내림차순 정렬
order(midwest$child_ratio)
# child_ratio를 기준으로 내림차순 정렬
order(midwest$child_ratio, decreasing = TRUE)
order(-midwest$child_ratio)
# child_ratio를 기준으로 내림차순 정렬
order(midwest$child_ratio, decreasing = TRUE) -> flag
# 행의 조건식에 order() 데이터를 대입
midwest[flag, ]
# 행의 조건식에 order() 데이터를 대입
midwest[flag, ] -> midwest
# 상위 5개의 지역을 확인
head(midwest, 5)
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total)
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total) %>%
mutate(child = total - adult)
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total) %>%
mutate(child = total - adult) %>%
mutate(child_ratio = (child / total) * 100)
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total) %>%
mutate(child = total - adult) %>%
mutate(child_ratio = (child / total) * 100) %>%
arrange(desc(child_ratio))
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total) %>%
mutate(child = total - adult) %>%
mutate(child_ratio = (child / total) * 100) %>%
arrange(desc(child_ratio)) %>%
head(5)
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total) %>%
mutate(child = total - adult,
child_ratio = (child / total) * 100) %>%
arrange(desc(child_ratio)) %>%
head(5)
## 미성년 비율이 40% 이상이면 high
## 미성년 비율이 30%이상 40% 미만이면 middle
## 미성년 비율이 30% 미만이면 low
## 로 만들어진 데이터를 grade 컬럼에 대입
# grade 데이터의 빈도수를 출력하고 막대그래프로 표시
ifelse(
midwest$child_ratio >= 40,
'high',
ifelse(
midwest$child_ratio >= 30,
'middle',
'low'
))
midwest$child_ratio >= 40
midwest$child_ratio >= 40 -> flag
# 반복문인 for문의 기본형 : for (변수명 in 벡터데이터)
for (i in flag){
print(i)
}
# 반복문인 for문의 기본형 : for (변수명 in 벡터데이터)
new_result <- c()
_index <- 1
flag_index <- 1
midwest$child_ratio >= 30 -> flag2
flag2
flag[10:15]
flag[20:30]
flag[50:60]
flag[40:60]
flag[30:40]
flag[30:40]
flag2[30:40]
# 반복문인 for문의 기본형 : for (변수명 in 벡터데이터)
new_result <- c()
flag_index <- 1
for (i in flag){
if(i){
new_result[flag_index] <- 'high'
}else{
if(flag2[flag_index]){
new_result[flag_index] <- 'middle'
}else{
new_result[flag_index] <- 'low'
}
}
flag_index = flag_index + 1
}
new_result
new_result -> midwest$grade
# 빈도수 확인
table(midwest$grade)
qplot(midwest$grade)
### dplyr 패키지 이용
midwest2 %>%
select(county, adult, total) %>%
mutate(child = total - adult,
child_ratio = (child / total) * 100) %>%
arrange(desc(child_ratio)) %>%
mutate(grade = ifelse(
child_ratio >= 40,
'high',
ifelse(
child_ratio >= 30,
'middle',
'low'
)
)) %>%
group_by(grade) %>%
summarise(count = n())
#결측치가 존재하는 데이터프레임 생성
c1 = c(1, 2, NA, 4, 5)
c2 = c(1, 2, 3, 4, 5)
c3 = c(NA, NA, 3, 4, 5)
df <- data.frame(c1, c2, c3)
df
# 결측치의 존재 유무
str(df)
# 결측치의 존재 유무
is.na(df)
# 결측치의 존재 유무
!is.na(df)
# 결측치의 존재 유무
is.na(df)
# 결측치의 개수를 확인
table(is.na(df))
# c3 컬럼에 데이터가 결측치인 데이터를 확인
table(is.na(df$c3))
df[is.na(df$c3), ]
df[!is.na(df$c3), ]
df %>% filter(is.na(c3))
# 결측치가 존재하는 벡터데이터를 연산
mean(df$c1)
mean(df$c2)
mean(df$c3)
min(df$c1)
max(df$c3)
mean(df$c3, na.rm = T)
df[!is.na(df$c3), ]
df[!is.na(df$c3), ] -> df2
mean(df2$c3)
# csv_exam.csv 파일 로드
read.csv("csv/csv_exam.csv")
# csv_exam.csv 파일 로드
read.csv("csv/csv_exam.csv") -> exam
# 데이터프레임에 결측치를 대입
exam[c(4, 9, 16), 'math']
# 데이터프레임에 결측치를 대입
exam[c(4, 9, 16), 'math'] <- NA
table(is.na(exam))
# exam 데이터프레임에서 class별 수학 성적에 평균 값을 출력
exam %>%
group_by(class) %>%
summarise(mean_math = mean(math))
# exam 데이터프레임에서 class별 수학 성적에 평균 값을 출력
exam %>%
group_by(class) %>%
summarise(mean_math = mean(math, na.rm=T))
exam %>%
filter(!is.na(math)) %>%
group_by(class) %>%
summarise(mean_math = mean(math))
# 결측치를 다른 데이터로 변경
# 수학 성적의 평균 값으로 해당하는 결측치 대체
mean(exam$math, na.rm = T)
# 결측치를 다른 데이터로 변경
# 수학 성적의 평균 값으로 해당하는 결측치 대체
mean(exam$math, na.rm = T) -> mean_math
ifelse(is.na(exam$math), mean_math, exam$math)
exam$math = ifelse(is.na(exam$math), mean_math, exam$math)
exam
mpg <- ggplot2::mpg
table(is.na(mpg))
str(mpg)
# 고속도로 연비 데이터를 기준으로 극단치 확인
boxplot(mpg$hwy)
# boxplot() 극단치의 경계를 수치로 출력
boxplot(mpg$hwy)$state
# boxplot() 극단치의 경계를 수치로 출력
boxplot(mpg$hwy)$stats
mpg$hwy < 12
mpg$hwy > 37
mpg$hwy < 12 | mpg$hwy > 37
mpg$hwy < 12 | mpg$hwy > 37 -> flag
mpg[flag, ]
ifelse(flag, NA, mpg$hwy)
ifelse(flag, NA, mpg$hwy) -> mpg$hwy
mpg %>%
group_by(manufacturer) %>%
summarise(mean_hwy = mean(hwy))
mpg %>%
group_by(manufacturer) %>%
summarise(mean_hwy = mean(hwy, na.rm=T))
mpg %>%
group_by(manufacturer) %>%
summarise(mean_hwy = mean(hwy, na.rm=T)) %>%
arrange(-mean_hwy)
mpg %>%
group_by(manufacturer) %>%
summarise(mean_hwy = mean(hwy, na.rm=T)) %>%
arrange(-mean_hwy) %>%
head(3)
mpg %>%
filter(is.na(hwy))
mpg %>%
filter(!is.na(hwy)) %>%
group_by(manufacturer) %>%
summarise(mean_hwy = mean(hwy)) %>%
arrange(desc(mean_hwy)) %>%
head(3)
